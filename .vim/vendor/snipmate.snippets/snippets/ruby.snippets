
snippet #!
	#!/usr/bin/env ruby

snippet y?
	yield ${1} if block_given?

snippet br
	begin
		${3}
	rescue ${1:Exception} => ${2:e}
	end

snippet fo
	File.open('${1:file_name}', '${2:w+}') do |f|
		f.${3}
	end

snippet req
	require "${1}"${2}

snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end

snippet when
	when ${1:condition} then
		${2}

snippet def
	def ${1:method_name}
		${2}
	end

snippet deft
	def test_${1:case_name}
		${2}
	end

snippet defs
	def self.${1:class_method_name}
		${2}
	end

snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end

snippet while
	while ${1:condition}
		${2}
	end

snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end

snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end

	end
snippet cla class .. < ParentClass .. initialize .. end

	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end

	end

snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end

	end

snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
snippet cla class << self .. end
	class << ${1:self}
		${2}
	end

snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end

	end

snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end


snippet r
	attr_reader :${1:attr_names}

snippet w
	attr_writer :${1:attr_names}

snippet rw
	attr_accessor :${1:attr_names}

snippet am
	alias_method :${1:new_name}, :${2:old_name}

snippet al
	alias :${1:alias} :${2:name}

snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end

snippet lam
	lambda { |${1:args}| ${2} }

snippet ->
	->(${1:args}) { ${2} }

snippet do|
	do |${1:variable}|
		${2}
	end

snippet do
	do
		${1}
	end

snippet : =>
	:${1:key} => ${2:"value"}${3}

snippet :
	${1:key}: ${2:"value"}${3}

snippet ope
	open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }

snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}) { ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}) { ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet ass assert_same(..)
	assert_same(${1:expected}, ${2:actual})${3}
snippet ass assert_send(..)
	assert_send([${1:object}, :${2:message}, ${3:args}])${4}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}) { ${2} }
snippet asnt
	assert_nothing_thrown { ${1} }


snippet con
	context "${1:context}" do
		${2}
	end

snippet desc
	describe "${1:description}" do
		${2}
	end

# RSpec Old
#==========================
snippet bea
	before :each do
		${1}
	end

snippet it'
	it '${1:do someting}'

snippet it
	it '${1:do_somethign}' do
		${2}
	end

snippet .sr
	.should_receive(:${1}).${2}

snippet .w
	.with(:${1})
snippet .ar
	.and_return(:${1})
snippet .re
	.raise_error
snippet .sh
	.should
snippet .sdn
	.should_not

# Rspec New
#==========================

snippet subj
	subject { ${1} }

snippet subjd
	subject do
		${1}
	end

snippet let
	let(:${1:name}) { ${2:val} }
